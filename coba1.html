<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>8-Bit City Stack</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body { 
      margin: 0; padding: 0; overflow: hidden; 
      background: #000; 
      display: flex; justify-content: center; align-items: center; height: 100vh;
      font-family: 'Press Start 2P', cursive; 
    }
    canvas { 
      box-shadow: 0 0 30px rgba(0,0,0,0.8);
      border: 4px solid #333;
      border-radius: 4px;
      image-rendering: pixelated; 
    }
  </style>
</head>
<body>
<script>
    const Engine = Matter.Engine,
          World = Matter.World,
          Bodies = Matter.Bodies,
          Body = Matter.Body,
          Runner = Matter.Runner,
          Events = Matter.Events;

    let engine, world;
    let blocks = [];
    let floor, foundation;
    let bgImage, blockImage; 

    const BLOCK_SIZE = 60;
    const MAGNET_RANGE_X = 30; 
    const MAGNET_RANGE_Y = 100; 
    const MAGNET_FORCE = 0.0005; 
    const STABILIZER_FORCE = 0.01; 
    
    let currentBlock = null; 
    let isGameOver = false;
    let score = 0;
    let camY = 0;
    let groundY; 
    let blockCounter = 1; 

    function preload() {
        bgImage = loadImage('assets/background.jpg');
        blockImage = loadImage('assets/block.png');
    }

    function setup() {
        createCanvas(windowHeight * 0.56, windowHeight);
        groundY = height - 100;

        engine = Engine.create();
        world = engine.world;
        engine.world.gravity.y = 1.2; 

        // Tanah & Pondasi
        floor = Bodies.rectangle(width/2, groundY + 100, width * 2, 200, { isStatic: true, label: 'floor' });
        World.add(world, floor);

        foundation = Bodies.rectangle(width/2, groundY, 80, 40, { 
            isStatic: true, label: 'foundation', friction: 1.0, restitution: 0.0
        });
        World.add(world, foundation);

        // --- DETEKSI TABRAKAN (Untuk Logic Kamera) ---
        Events.on(engine, 'collisionStart', (e) => {
            e.pairs.forEach(pair => {
                let bodyA = pair.bodyA;
                let bodyB = pair.bodyB;

                // Cek Game Over
                if((bodyA.label === 'floor' && bodyB.label === 'block') || 
                   (bodyB.label === 'floor' && bodyA.label === 'block')) {
                    gameOver();
                }

                // Cek Pendaratan Blok (Agar Kamera Mau Mengikuti)
                // Jika block menabrak block lain atau foundation, tandai "hasLanded = true"
                if (bodyA.label === 'block') bodyA.hasLanded = true;
                if (bodyB.label === 'block') bodyB.hasLanded = true;
            });
        });

        Runner.run(engine);
        spawnNextBlock();
        textFont('Press Start 2P');
    }

    function draw() {
        drawingContext.imageSmoothingEnabled = false; 

        background(20); 
        if (bgImage) image(bgImage, 0, 0, width, height);

        if (!isGameOver) {
            updateCrane();
            applySmoothMagnet(); 
        }

        // ==========================================
        // LOGIC KAMERA ANTI-JEGLEK
        // ==========================================
        let targetY = 0;
        let highestLandedBlock = null;

        // Cari blok paling atas yang SUDAH pernah mendarat
        // Kita loop dari blok terakhir ke pertama
        for (let i = blocks.length - 1; i >= 0; i--) {
            if (blocks[i].hasLanded) {
                highestLandedBlock = blocks[i];
                break; // Ketemu yang paling atas, stop loop
            }
        }

        // Jika ada blok yang sudah mendarat dan posisinya tinggi, kamera naik
        if (highestLandedBlock && highestLandedBlock.position.y < height/2) {
            targetY = -(highestLandedBlock.position.y - height/2) - 80;
        }

        // Gerakan kamera diperhalus (lerp)
        camY = lerp(camY, targetY, 0.05);
        // ==========================================


        push();
        translate(0, camY);

        // Visual Tanah
        noStroke(); fill(40); rectMode(CENTER);
        rect(width/2, groundY + 100, width, 200);
        fill(255);
        rect(width/2, groundY + 10, width, 4);

        // Visual Pondasi
        fill(100); stroke(0); strokeWeight(4);
        rect(foundation.position.x, foundation.position.y, 80, 40);
        drawMagnetGlow(foundation.position.x, foundation.position.y - 20, 80);

        for (let b of blocks) drawBlock(b);
        if (currentBlock) drawCrane();

        pop();

        drawUI();
    }

    function drawBlock(b) {
        let pos = b.position;
        push();
        translate(pos.x, pos.y);
        rotate(b.angle);
        imageMode(CENTER); rectMode(CENTER);

        if (blockImage) {
            image(blockImage, 0, 0, BLOCK_SIZE, BLOCK_SIZE);
        } else {
            fill(255); stroke(0); strokeWeight(2);
            rect(0, 0, BLOCK_SIZE, BLOCK_SIZE);
        }

        fill(255); stroke(0); strokeWeight(4);
        textSize(14); textAlign(CENTER, CENTER);
        text(b.gameNumber, 0, 0);

        if (b.speed < 0.2) drawMagnetGlow(0, -BLOCK_SIZE/2, BLOCK_SIZE);
        pop();
    }

    function drawCrane() {
        stroke(180); strokeWeight(4);
        let startY = -camY;
        let endY = currentBlock.y;
        
        for(let i=startY; i<endY; i+=15) {
            line(width/2, i, width/2, i+8);
        }
        line(width/2, currentBlock.y - 20, currentBlock.x, currentBlock.y);

        push();
        translate(currentBlock.x, currentBlock.y);
        imageMode(CENTER); rectMode(CENTER);
        
        if (blockImage) {
            image(blockImage, 0, 0, BLOCK_SIZE, BLOCK_SIZE);
        } else {
            fill(255); stroke(0); strokeWeight(2);
            rect(0, 0, BLOCK_SIZE, BLOCK_SIZE);
        }
        
        fill(255); stroke(0); strokeWeight(4);
        textSize(14); textAlign(CENTER, CENTER);
        text(currentBlock.number, 0, 0);
        pop();
    }

    function drawMagnetGlow(x, y, w) {
        noStroke();
        fill(255, 255, 255, 50); 
        rectMode(CENTER);
        rect(x, y, w, 4);
    }

    function drawUI() {
        fill(255); stroke(0); strokeWeight(4);
        textSize(16); textAlign(LEFT, TOP);
        text("FLOOR: " + score, 20, 20);

        if (isGameOver) {
            fill(0, 0, 0, 200);
            rectMode(CORNER);
            rect(0,0,width,height);
            fill(255, 50, 50); textAlign(CENTER, CENTER);
            textSize(24); text("GAME OVER", width/2, height/2 - 20);
            fill(255); textSize(12); text("Tap to Restart", width/2, height/2 + 20);
        }
    }

    function applySmoothMagnet() {
        if (blocks.length === 0) return;
        for (let i = 0; i < blocks.length; i++) {
            let fallingBlock = blocks[i];
            let baseBlock = (i === 0) ? foundation : blocks[i-1];
            
            let dx = fallingBlock.position.x - baseBlock.position.x;
            let dy = fallingBlock.position.y - baseBlock.position.y;
            
            if (Math.abs(dx) < MAGNET_RANGE_X && dy < 0 && Math.abs(dy) < MAGNET_RANGE_Y) {
                stroke(255, 255, 255, 100); strokeWeight(1);
                line(fallingBlock.position.x, fallingBlock.position.y, baseBlock.position.x, baseBlock.position.y);

                let forceX = -dx * MAGNET_FORCE; 
                Body.applyForce(fallingBlock, fallingBlock.position, { x: forceX, y: 0 });
                let angleCorrection = -fallingBlock.angle * STABILIZER_FORCE;
                fallingBlock.torque = angleCorrection;
                fallingBlock.frictionAir = 0.1; 
            } else {
                fallingBlock.frictionAir = 0.01; 
            }
        }
    }

    function spawnNextBlock() {
        if (isGameOver) return;
        currentBlock = {
            x: width/2, y: -camY + 80,
            angle: 0, swingSpeed: 0.03 + (score * 0.0005),
            number: blockCounter
        };
    }

    function updateCrane() {
        if (!currentBlock) return;
        currentBlock.angle += currentBlock.swingSpeed;
        currentBlock.x = (width/2) + Math.sin(currentBlock.angle) * (width/2 - 60);
        currentBlock.y = -camY + 80;
    }

    function mousePressed() {
        if (isGameOver) resetGame();
        else if (currentBlock) dropBlock();
    }

    function dropBlock() {
        let b = Bodies.rectangle(currentBlock.x, currentBlock.y, BLOCK_SIZE, BLOCK_SIZE, {
            restitution: 0.0, friction: 0.5, frictionAir: 0.01, density: 0.005,
            label: 'block'
        });
        
        b.gameNumber = currentBlock.number; 
        
        // PENTING: Penanda bahwa blok ini belum mendarat
        b.hasLanded = false; 

        let swingForce = Math.cos(currentBlock.angle) * 1.5;
        Body.setVelocity(b, {x: swingForce, y: 0});

        World.add(world, b);
        blocks.push(b);
        blockCounter++; 

        let target = (blocks.length > 1) ? blocks[blocks.length-2] : foundation;
        if (Math.abs(currentBlock.x - target.position.x) < 20) score += 2; else score += 1;

        currentBlock = null;
        setTimeout(spawnNextBlock, 800);
    }

    function gameOver() { isGameOver = true; }
    
    function resetGame() {
        blocks.forEach(b => World.remove(world, b));
        blocks = [];
        score = 0; blockCounter = 1; 
        isGameOver = false; camY = 0;
        spawnNextBlock();
    }
    
    function windowResized() {
        resizeCanvas(windowHeight * 0.56, windowHeight);
        groundY = height - 100;
        Body.setPosition(foundation, {x: width/2, y: groundY});
        Body.setPosition(floor, {x: width/2, y: groundY + 100});
    }
</script>
</body>
</html>