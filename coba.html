<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Active Magnet Stack</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <style>
    body { 
      margin: 0; padding: 0; overflow: hidden; 
      background: #1a1a1a; 
      display: flex; justify-content: center; align-items: center; height: 100vh;
      font-family: sans-serif;
    }
    canvas { 
      box-shadow: 0 10px 30px rgba(0,0,0,0.8);
      border: 2px solid #333;
    }
  </style>
</head>
<body>
<script>
    const Engine = Matter.Engine,
          World = Matter.World,
          Bodies = Matter.Bodies,
          Body = Matter.Body,
          Runner = Matter.Runner,
          Events = Matter.Events;

    let engine, world;
    let blocks = [];
    let floor, foundation;
    
    // Config
    const BLOCK_SIZE = 60;
    
    // --- SETTINGAN MAGNET ---
    // Jarak horizontal di mana magnet mulai menarik (jangan terlalu jauh biar ga aneh)
    const MAGNET_RANGE_X = 50; 
    // Jarak vertikal (tinggi) di mana magnet "mendeteksi" balok jatuh
    const MAGNET_RANGE_Y = 80; 
    
    const MAGNET_FORCE = 0.003; // Kekuatan tarik ke tengah
    const STABILIZER_FORCE = 0.05; // Kekuatan menahan rotasi (agar tegak)
    
    let currentBlock = null; 
    let isGameOver = false;
    let score = 0;
    let camY = 0;
    let groundY; 

    function setup() {
        createCanvas(windowHeight * 0.56, windowHeight);
        groundY = height - 100;

        engine = Engine.create();
        world = engine.world;
        engine.world.gravity.y = 1.3; 

        // Tanah
        floor = Bodies.rectangle(width/2, groundY + 100, width * 2, 200, { isStatic: true, label: 'floor' });
        World.add(world, floor);

        // Pondasi
        foundation = Bodies.rectangle(width/2, groundY, 80, 40, { 
            isStatic: true, 
            label: 'foundation',
            friction: 1.0, restitution: 0.0
        });
        World.add(world, foundation);

        // Game Over Check
        Events.on(engine, 'collisionStart', (e) => {
            e.pairs.forEach(pair => {
                if((pair.bodyA.label === 'floor' && pair.bodyB.label === 'block') || 
                   (pair.bodyB.label === 'floor' && pair.bodyA.label === 'block')) {
                    gameOver();
                }
            });
        });

        Runner.run(engine);
        spawnNextBlock();
    }

    function draw() {
        background(30, 35, 40);

        if (!isGameOver) {
            updateCrane();
            applyMagneticField(); // Logika magnet aktif
        }

        // Kamera Halus
        let targetY = 0;
        if (blocks.length > 0) {
            let topBlock = blocks[blocks.length-1];
            if(topBlock.position.y < height/2) {
                targetY = -(topBlock.position.y - height/2) - 80;
            }
        }
        camY = lerp(camY, targetY, 0.05);

        push();
        translate(0, camY);

        // Gambar Tanah
        noStroke(); fill(50);
        rectMode(CENTER);
        rect(width/2, groundY + 100, width, 200);
        
        // Gambar Pondasi dengan Visual Magnet
        fill(80); stroke(100); strokeWeight(2);
        rect(foundation.position.x, foundation.position.y, 80, 40);
        // Visual Magnet Pondasi
        drawMagnetGlow(foundation.position.x, foundation.position.y - 20, 80);

        // Gambar Balok
        for (let b of blocks) drawBlock(b);

        // Gambar Crane
        if (currentBlock) drawCrane();

        pop();
        drawUI();
    }

    // ==========================================
    // LOGIKA MAGNET AKTIF (ATAS BAWAH)
    // ==========================================
    function applyMagneticField() {
        if (blocks.length === 0) return;

        // Cek setiap balok
        for (let i = 0; i < blocks.length; i++) {
            let fallingBlock = blocks[i];
            
            // Tentukan target di bawahnya (Foundation atau Balok sebelumnya)
            let baseBlock = (i === 0) ? foundation : blocks[i-1];
            
            // Hitung jarak
            let dx = fallingBlock.position.x - baseBlock.position.x;
            let dy = fallingBlock.position.y - baseBlock.position.y;
            
            // LOGIKA MAGNET:
            // Aktif jika:
            // 1. Jarak horizontal dekat (MAGNET_RANGE_X)
            // 2. Jarak vertikal dekat tapi di atasnya (MAGNET_RANGE_Y)
            if (Math.abs(dx) < MAGNET_RANGE_X && dy < 0 && Math.abs(dy) < MAGNET_RANGE_Y) {
                
                // Visualisasi sambungan magnet (garis tipis)
                stroke(0, 255, 255, 100);
                strokeWeight(1);
                line(fallingBlock.position.x, fallingBlock.position.y, baseBlock.position.x, baseBlock.position.y);

                // 1. Tarik ke tengah (Force X)
                // Semakin dekat, tarikan semakin presisi
                let forceX = -dx * MAGNET_FORCE; 
                Body.applyForce(fallingBlock, fallingBlock.position, { x: forceX, y: 0 });

                // 2. Stabilizer Rotasi (Agar mendarat datar)
                // Jika balok miring, putar balik pelan-pelan
                let angleCorrection = -fallingBlock.angle * STABILIZER_FORCE;
                fallingBlock.torque = angleCorrection;
                
                // Tandai sedang ditarik (untuk visual)
                fallingBlock.isBeingPulled = true;
            } else {
                fallingBlock.isBeingPulled = false;
            }
        }
    }

    // ==========================================
    // VISUALISASI
    // ==========================================
    
    function drawMagnetGlow(x, y, w) {
        // Efek cahaya magnet di atas balok/pondasi
        noStroke();
        // Glow luar
        fill(0, 255, 255, 30); 
        rect(x, y, w, 10, 5);
        // Glow inti
        fill(0, 255, 255, 150); 
        rect(x, y + 3, w - 10, 2, 2);
    }

    function drawBlock(b) {
        let pos = b.position;
        push();
        translate(pos.x, pos.y);
        rotate(b.angle);
        rectMode(CENTER);

        // Body Balok
        stroke(0); strokeWeight(2);
        fill(b.renderColor);
        rect(0, 0, BLOCK_SIZE, BLOCK_SIZE, 4);

        // VISUAL MAGNET (Hanya jika balok sudah mendarat/lambat)
        // Ini menandakan dia "SIAP MENERIMA" balok baru
        if (b.speed < 0.5) { 
             // Gambar magnet di sisi ATAS balok ini
             drawMagnetGlow(0, -BLOCK_SIZE/2, BLOCK_SIZE);
        }

        // Indikator sedang ditarik magnet bawahnya
        if (b.isBeingPulled) {
            stroke(0, 255, 255);
            strokeWeight(2);
            noFill();
            rect(0, 0, BLOCK_SIZE, BLOCK_SIZE, 4);
        }

        pop();
    }

    // ==========================================
    // LOGIKA GAME
    // ==========================================

    function spawnNextBlock() {
        if (isGameOver) return;
        currentBlock = {
            x: width/2,
            y: -camY + 80,
            angle: 0,
            swingSpeed: 0.03 + (score * 0.0005),
            color: color(random(100,200), random(150,220), random(200,255))
        };
    }

    function updateCrane() {
        if (!currentBlock) return;
        currentBlock.angle += currentBlock.swingSpeed;
        currentBlock.x = (width/2) + Math.sin(currentBlock.angle) * (width/2 - 60);
        currentBlock.y = -camY + 80;
    }

    function mousePressed() {
        if (isGameOver) resetGame();
        else if (currentBlock) dropBlock();
    }

    function dropBlock() {
        let b = Bodies.rectangle(currentBlock.x, currentBlock.y, BLOCK_SIZE, BLOCK_SIZE, {
            restitution: 0.1, friction: 0.8, frictionAir: 0.02, density: 0.002, label: 'block'
        });
        b.renderColor = currentBlock.color;
        b.isBeingPulled = false;

        let swingForce = Math.cos(currentBlock.angle) * 1.5;
        Body.setVelocity(b, {x: swingForce, y: 0});

        World.add(world, b);
        blocks.push(b);
        
        // Scoring
        let target = (blocks.length > 1) ? blocks[blocks.length-2] : foundation;
        if (Math.abs(currentBlock.x - target.position.x) < 20) score += 2; else score += 1;

        currentBlock = null;
        setTimeout(spawnNextBlock, 800);
    }

    function drawCrane() {
        stroke(200); strokeWeight(1);
        line(width/2, -camY, currentBlock.x, currentBlock.y);
        fill(currentBlock.color); noStroke();
        rectMode(CENTER);
        rect(currentBlock.x, currentBlock.y, BLOCK_SIZE, BLOCK_SIZE, 3);
    }

    function drawUI() {
        fill(255); noStroke(); textSize(24); textAlign(LEFT, TOP);
        text(score, 20, 20);

        if (isGameOver) {
            fill(0, 0, 0, 200);
            rectMode(CORNER);
            rect(0,0,width,height);
            fill(255); textAlign(CENTER, CENTER);
            textSize(32); text("GAME OVER", width/2, height/2);
            textSize(16); text("Tap to Restart", width/2, height/2 + 40);
        }
    }

    function gameOver() { isGameOver = true; }
    
    function resetGame() {
        blocks.forEach(b => World.remove(world, b));
        blocks = [];
        score = 0;
        isGameOver = false;
        camY = 0;
        spawnNextBlock();
    }
    
    function windowResized() {
        resizeCanvas(windowHeight * 0.56, windowHeight);
        groundY = height - 100;
        Body.setPosition(foundation, {x: width/2, y: groundY});
        Body.setPosition(floor, {x: width/2, y: groundY + 100});
    }
</script>
</body>
</html>